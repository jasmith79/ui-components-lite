import*as DOM from'./dom.min.js';import processHTMLAttr from'./attribute-analyzer.min.js';import extractType from'../../../extracttype/extracttype.js';const attrConf={attributes:!0},isHTMLElement=(a)=>!!extractType(a).match(/HTML[a-zA-Z]*Element/);export default((a)=>class extends a{constructor(){super(),this._mutationObservers=[],this._prevDisplay='',this._isHidden=!1}get isVisible(){const a=DOM.global.getComputedStyle(this);return'none'!==a.display&&'hidden'!==a.visibility&&'0'!==a.opacity}watchAttribute(b,c,a){const[d,e,f]=(()=>isHTMLElement(b)?[b,c,a]:[this,b,c])();if((d.constructor.observedAttributes||[]).includes(e))d.on('attribute-change',({changed:{now:a,name:b,was:c}})=>{b===e&&f(a,b,c)});else{const a=new MutationObserver(([a])=>{a.attributeName===e&&f(d.attr(a.attributeName),a.attributeName,a.oldValue)});a.observe(d,attrConf),this._mutationObservers.push([a,d,attrConf])}return this}selectAll(a){const b=this.querySelectorAll(a);return b?[...b]:[]}matches(a){if(super.matches)return super.matches(a);if(super.msMatchesSelector)return super.msMatchesSelector(a);throw new Error('HTMLElement does not implement the matches method.')}selectInternalElement(a){return this.shadowRoot?this.shadowRoot.querySelector(a):(console.warn(`Internal selector ${a} called on ${this.identity} which has no shadowRoot.`),null)}selectInternalAll(a){return this.shadowRoot?[...this.shadowRoot.querySelectorAll(a)]:(console.warn(`Internal selector ${a} called on ${this.identity} which has no shadowRoot.`),null)}get identity(){let a=this.id?'#'+this.id:'',b=this.tagName.toLowerCase(),c='.'+this.attr('class').split(' ').filter((a)=>a!==b).join('.');return`${b}${a}${c}`}on(a,b){return a.split(/\s+/g).forEach((a)=>{const c=this._listeners.some(([c,d])=>c===a&&b===d);c||(this.addEventListener(a,b),this._listeners.push([a,b]))}),this}remove(...a){const[b,c,d]=((a)=>{switch(a.length){case 0:return this.parentElement&&this.parentElement.removeChild(this),[];case 1:return(([a])=>{const b=extractType(a);return'Function'===b?[null,a]:isHTMLElement(a)||'Text'===b?[null,null,[a]]:[]})(a);default:return((a)=>{const[b]=a;return isHTMLElement(b)||'Text'===extractType(b)?[null,null,a]:a.slice(0,2)})(a);}})(a);return c&&'Function'===extractType(c)&&(this._listeners=this._listeners.filter(([a,d])=>d===c&&(null===b||b===a)?(this.removeEventListener(a,d),!1):!0)),d&&d.forEach((a)=>this.removeChild(a)),this}hide(){return this._isHidden||(this._prevDisplay=this.style.display,this._isHidden=!0,this.style.display='none'),this}show(){return this._isHidden&&(this.style.display=this._prevDisplay,this._isHidden=!1),this}attr(a,b){if(b===void 0)return processHTMLAttr(this.getAttribute(a));switch(extractType(b)){case'Null':this.removeAttribute(a);break;default:this.setAttribute(a,b);}return this}appendFirst(a,b){const c=b?this.shadowRoot:this;if(!c)throw new TypeError(`Attempted to append to shadowRoot but none exists on element ${this.identity}`);return c.children.length?c.insertBefore(a,c.children[0]):c.appendChild(a),this}});